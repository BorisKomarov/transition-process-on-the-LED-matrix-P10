# Вывод графика переходного процесса на светодиодную матрицу p10
Задачи: 
1.	Реализовать вывод переходного процесса колебательного звена второго порядка на светодиодную матрицу по интерфейсу SPI
2.	Реализовать вывод реакции переходного процесса на импульс, генерируемые нажатием кнопки 


ХОД РАБОТЫ

В данной работе под внешним устройством подразумевается использование светодиодной матрицы P10, имеющей разрешение 16x32 светодиода 

![matrixp10](https://github.com/BorisKomarov/transition-process-on-the-LED-matrix-P10/assets/151782169/40c7b4b3-7ce0-45f5-ad90-0d4fdaac1d0a)

В работе задействуются следующие линии матрицы:

A и B –  контакты мультиплексирования, задают, какая из 4 групп светодиодов экрана работает в данный момент

nOE – разрешение работы матрицы

CLK — линия синхронизации

R — линия данных 

SCLK – линия для защёлкивания переданных в сдвиговые регистры данных на их выходы

![pins](https://github.com/BorisKomarov/transition-process-on-the-LED-matrix-P10/assets/151782169/b0a6d6d8-1f05-4bdc-8180-e0e8813501bf)

Исходя из используемых линий обозначим используемые пины в CubeMX 

![pinCUBE](https://github.com/BorisKomarov/transition-process-on-the-LED-matrix-P10/assets/151782169/8f64dd4a-f9be-4c37-a3e5-4ee3a6a8c3d4)

Далее создадим проект и напишем код программы.Разберём код программы по частям. Первая часть изображена ниже.

```
1.	   for (int i =0; i<16;i++){
2.		  data_11[i] =0xff;
3.		  data_10[i] =0xff;
4.		  data_01[i] =0xff;
5.		  data_00[i] =0xff;
6.	   }
7.	   w = sqrt(1-pow(psi,2))/T;
8.	   a = psi/T;
```

Здесь происходит начальная инициализация массивов данных, которые будут отправляться на матрицу и расчёт некоторых значений, используемых в формуле расчёта переходного процесса.
Далее рассмотрим код, выполняемые в бесконечном цикле while.

```
9.	while (1) {
10.	    btn = HAL_GPIO_ReadPin(BTN_GPIO_Port, BTN_Pin);
11.	    if (btn) {
12.	        pressed_flag = 1;
13.	        imp_time = time;
14.	    }
15.	 
16.	    h = (k * (1 - pow(e, -psi * time / T) * (cos(w * time) + (psi / sqrt(1 - pow(psi, 2))) * sin(w * time)))) +
17.	        pressed_flag * (k / 1.7 * ((w + pow(a, 2)) / w) * sin(w * (time - imp_time)) * pow(e, -a * (time - imp_time))); // расчёт значение переходной функции
18.	    hk = round(h / step_h) * step_h; // квантование  значений функции
19.	    tk = round(time / step_time) * step_time; // квантование  времени

```
 В переменную btnState считывается состояние кнопки для учёта реакции переходного процесса на импульс, генерируемые нажатием кнопки. 
 Далее рассчитывается значение переходного процесса, который зависит от  переменной времени time, увеличивающейся каждый цикл.  
 При нажатии кнопки к переходному процессу прибавляется значения реакции на импульс.

 Далее выполняется квантование  времени и значения функции с шагом step_h и stem_time.

 После этого выполняется участок кода для записи значений в массивы данных, которые отправляются на матрицу. 
 В условии выполняется проверка равенства предыдущих и текущих квантованных значений для того, чтобы избежать повторяемость одних и тех же значений,
 не несущих полезной информации.

 Данные записываются в 4 массива по 16 байт, каждый из которых отправляется на матрицу в зависимости от линий A и B. Таким образом, для управления всеми светодиодами необходимо отправить 64 байта.
 Запись в массивы можно представить при помощи иллюстрации.

 ![primerzapisi](https://github.com/BorisKomarov/transition-process-on-the-LED-matrix-P10/assets/151782169/f75fa47f-b708-4f77-a908-9956e9043631)

Для записи данных для  квантованных значений рассчитывается номер строки и колонки, как будто данные записываются в двумерный массив 16x32 элемента, имитирующий саму светодиодную матрицу. 
Номера колонки и строки рассчитываются, исходя из шага квантования. В зависимости от значения текущей колонки формируется байт diodes_byte, в который записывается бит, 
где определено значение функции. Исходя из значения строки выбирается один из четырёх массивов, в который записывается данный байт. Далее, также используя значение col и row,
рассчитывается позиция конкретного байта, в который при помощи операции «&=» значение этого байта обновляется без стирания уже имеющейся в нём информации. 
Таким образом, формируются массивы данных для каждой группы светодиодов, зависящей от значений A и B. Данный код выполняется, пока по оси времени не заполнится вся матрица,
что реализуется использованием условия «if(col<=31)». Описываемый фрагмент кода представлен ниже.

```
20.	     if (tk != temp_tk || hk != temp_hk) {
21.	        temp_tk = tk;
22.	        temp_hk = hk;
23.	        col = round(tk / step_time);
24.	        row = round(hk / step_h);
25.	        diodes_byte = ~(mask >> (col % 8));
26.	 
27.	        if (col <= 31) {
28.	            if (row % 4 == 0) {
29.	                data_11[4 * (col / 8) + row / 4] &= diodes_byte;
30.	            } else if (row % 4 == 1) {
31.	                data_01[4 * (col / 8) + row / 4] &= diodes_byte;
32.	            } else if (row % 4 == 2) {
33.	                data_10[4 * (col / 8) + row / 4] &= diodes_byte;
34.	            } else if (row % 4 == 3) {
35.	                data_00[4 * (col / 8) + row / 4] &= diodes_byte;
36.	            }
37.	        }

```

 После этого, для вывода следующих значений, выходящих за границы матрицы, все байты необходимо сдвинуть на 1 бит, а в свободную колонку записать новые значения битов, что реализовано ниже.  

 ```
38.	else {
39.	            for (int i = 0; i < 12; i++) {
40.	                shifted_bit = (data_11[i + 4] >> 7) & 1;
41.	                data_11[i] <<= 1;
42.	                data_11[i] |= shifted_bit;
43.	            }
44.	            for (int i = 0; i < 12; i++) {
45.	                shifted_bit = (data_10[i + 4] >> 7) & 1;
46.	                data_10[i] <<= 1;
47.	                data_10[i] |= shifted_bit;
48.	            }
49.	            for (int i = 0; i < 12; i++) {
50.	                shifted_bit = (data_01[i + 4] >> 7) & 1;
51.	                data_01[i] <<= 1;
52.	                data_01[i] |= shifted_bit;
53.	            }
54.	            for (int i = 0; i < 12; i++) {
55.	                shifted_bit = (data_00[i + 4] >> 7) & 1;
56.	                data_00[i] <<= 1;
57.	                data_00[i] |= shifted_bit;
58.	            }
 ```

Сдвиг реализуется следующим образом: пусть есть байт 1 и байт 2. Сначала вычисляется значение старшего бита «shifted_bit» байта 2. 
Далее байт 1 сдвигается на одно значение, а в его младший бит записывается старший бит байта 2. Данная операция выполняется для 12 байтов в массиве, фрагмент кода алгоритма представлен ниже.

```
59.	            for (int i = 0; i < 3; i++) {
60.	                data_11[12 + i] <<= 1;
61.	                data_11[12 + i] |= 0b00000001;
62.	            }
63.	            for (int i = 0; i < 3; i++) {
64.	                data_10[12 + i] <<= 1;
65.	                data_10[12 + i] |= 0b00000001;
66.	            }
67.	            for (int i = 0; i < 3; i++) {
68.	                data_01[12 + i] <<= 1;
69.	                data_01[12 + i] |= 0b00000001;
70.	            }
71.	            for (int i = 0; i < 3; i++) {
72.	                data_00[12 + i] <<= 1;
73.	                data_00[12 + i] |= 0b00000001;
74.	            }
```

Для последних четырёх байт выполняется изменённый код, так как в данные байты необходимо также записать новые значения в зависимости от переменной diodes_byte.

```
75.	            if (row % 4 == 0) {
76.	                shifted_bit = ((diodes_byte << col % 8) >> 7) & 1;
77.	                shifted_bit |= 0b11111110;
78.	                data_11[12 + row / 4] &= shifted_bit;
79.	            }
80.	            if (row % 4 == 1) {
81.	                shifted_bit = ((diodes_byte << col % 8) >> 7) & 1;
82.	                shifted_bit |= 0b11111110;
83.	                data_01[12 + row / 4] &= shifted_bit;
84.	            }
85.	            if (row % 4 == 2) {
86.	                shifted_bit = ((diodes_byte << col % 8) >> 7) & 1;
87.	                shifted_bit |= 0b11111110;
88.	                data_10[12 + row / 4] &= shifted_bit;
89.	            }
90.	            if (row % 4 == 3) {
91.	                shifted_bit = ((diodes_byte << col % 8) >> 7) & 1;
92.	                shifted_bit |= 0b11111110;
93.	                data_00[12 + row / 4] &= shifted_bit;
94.	            }
95.	        }
96.	    }
97.	}
98.	time+=0.01;
```

Далее необходимо отправить данные на матрицу, что реализовано во фрагменте кода ниже.


```
99.	// смена значений A и B
100.	A = (AB_counter % 2 == 0) ? 1 : 0;
101.	B = (AB_counter / 2 % 2 == 0) ? 1 : 0;
102.	AB_counter = (AB_counter + 1) % 4;
103.	 
104.	HAL_GPIO_WritePin(NOE_GPIO_Port, NOE_Pin, GPIO_PIN_RESET);
105.	 
106.	HAL_GPIO_WritePin(A_GPIO_Port, A_Pin, A);
107.	HAL_GPIO_WritePin(B_GPIO_Port, B_Pin, B);
108.	 
109.	// Отправка данных в зависимости от уровней A и B
110.	if (A == 1 && B == 1) {
111.	    HAL_SPI_Transmit(&hspi2, &data_11, 16, 10);
112.	}
113.	if (A == 0 && B == 1) {
114.	    HAL_SPI_Transmit(&hspi2, &data_01, 16, 10);
115.	}
116.	if (A == 1 && B == 0) {
117.	    HAL_SPI_Transmit(&hspi2, &data_10, 16, 10);
118.	}
119.	if (A == 0 && B == 0) {
120.	    HAL_SPI_Transmit(&hspi2, &data_00, 16, 10);
121.	}
122.	 
123.	HAL_GPIO_WritePin(SCLK_GPIO_Port, SCLK_Pin, GPIO_PIN_RESET);
124.	HAL_GPIO_WritePin(SCLK_GPIO_Port, SCLK_Pin, GPIO_PIN_SET);
125.	 
126.	HAL_GPIO_WritePin(NOE_GPIO_Port, NOE_Pin, GPIO_PIN_SET);
127.	HAL_Delay(1);
```
Таким образом, реализован вывод переходного процесса на светодиодную матрицу, результат вывода показан на изображениях ниже.

![res](https://github.com/BorisKomarov/transition-process-on-the-LED-matrix-P10/assets/151782169/9d94c876-d50a-4cb8-a2cf-af9c7effb4ed)



 
